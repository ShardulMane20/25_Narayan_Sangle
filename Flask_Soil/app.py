from flask import Flask, request, jsonify, send_from_directory
from werkzeug.utils import secure_filename
from tensorflow.keras.models import load_model
import numpy as np
import pickle
from fpdf import FPDF
import os
import json
import torch
from torchvision import transforms, models
from PIL import Image
from flask_cors import CORS
import uuid

# Flask app setup
app = Flask(__name__)
CORS(app)

# Configuration for file uploads
UPLOAD_FOLDER = 'static/uploads'
REPORT_FOLDER = 'static/reports'
PDF_PATH = 'static/pdf_reports'
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['REPORT_FOLDER'] = REPORT_FOLDER

os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(REPORT_FOLDER, exist_ok=True)
os.makedirs(PDF_PATH, exist_ok=True)

# Load the TensorFlow model and encoders for fertilizer prediction
fertilizer_model = load_model('model/crop_fertilizer_model.h5')
with open('model/scaler.pkl', 'rb') as file:
    scaler = pickle.load(file)
with open('model/crop_encoder.pkl', 'rb') as file:
    crop_encoder = pickle.load(file)
with open('model/fertilizer_encoder.pkl', 'rb') as file:
    fertilizer_encoder = pickle.load(file)

# Load the PyTorch model for plant disease detection
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
disease_model = models.mobilenet_v2(pretrained=False)
disease_model.classifier[1] = torch.nn.Linear(disease_model.classifier[1].in_features, 14)
disease_model.load_state_dict(torch.load("model/best_plant_disease_model.pth", map_location=device))
disease_model.eval()
disease_model = disease_model.to(device)

class_to_idx= {'Pepper_bell_healthy': 0, 'Potato_Early_blight': 1, 'Potato_healthy': 2, 'Potato_Late_blight': 3, 'Tomato_Bacterial_spot': 4, 'Tomato_Early_blight': 5, 'Tomato_healthy': 6, 'Tomato_Late_blight': 7, 'Tomato_Leaf_Mold': 8, 'Tomato_mosaic_virus': 9, 'Tomato_Septoria_leaf_spot': 10, 'Tomato_Spider_mites_Two_spotted_spider_mite': 11, 'Tomato_Target_Spot': 12, 'Tomato_YellowLeaf__Curl_Virus': 13}

idx_to_class = {v: k for k, v in class_to_idx.items()}

# Load JSON data for plant disease solutions
with open('static/PlantSol.json') as json_file:
    plant_solutions = json.load(json_file)

# Define transformations for plant images
transform = transforms.Compose([
    transforms.Resize((128, 128)),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])

# Helper functions
def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def generate_pdf_report(content, output_path):
  try:
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=12)
    for line in content:
      pdf.cell(200, 10, txt=line, ln=True)
    pdf.output(output_path)
    return output_path  # Return the full path
  except Exception as e:
    print(f"Error generating PDF report: {e}")  # Log the error

def predict_image(img_path):
    try:
        image = Image.open(img_path).convert("RGB")
        image = transform(image).unsqueeze(0).to(device)

        with torch.no_grad():
            outputs = disease_model(image)
            _, predicted_class = torch.max(outputs, 1)
        return idx_to_class[predicted_class.item()]
    except Exception as e:
        return f"Error during prediction: {e}"
    
def generate_pdf_report(content, pdf_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()

    # Title Section
    pdf.set_font("Arial", style="B", size=16)
    pdf.set_text_color(0, 102, 204)  # Blue color
    pdf.cell(0, 10, "Crop Fertilizer Report", ln=True, align="C")
    pdf.ln(10)

    # Input Features Section
    pdf.set_font("Arial", style="B", size=14)
    pdf.set_text_color(0, 0, 0)  # Black color
    pdf.cell(0, 10, "Input Features:", ln=True)
    pdf.ln(5)

    pdf.set_font("Arial", size=12)
    for line in content[2:8]:
        pdf.cell(0, 10, line, ln=True)

    pdf.ln(10)  # Add spacing before the next section

    # Predictions Section
    pdf.set_font("Arial", style="B", size=14)
    pdf.set_text_color(34, 139, 34)  # Green color
    pdf.cell(0, 10, "Predictions:", ln=True)
    pdf.ln(5)

    pdf.set_font("Arial", size=12)
    pdf.set_text_color(0, 0, 0)  # Back to black text
    for line in content[8:]:
        pdf.cell(0, 10, line, ln=True)

    # Footer Section
    pdf.ln(15)
    pdf.set_font("Arial", style="I", size=10)
    pdf.set_text_color(128, 128, 128)  # Gray color
    pdf.cell(0, 10, "Generated by Crop Fertilizer Prediction System", ln=True, align="C")

    # Save the PDF
    pdf.output(pdf_path)
    return pdf_path

# Main Route Function
@app.route('/predict_fertilizer', methods=['POST'])
def predict_fertilizer():
    try:
        # Extract input features
        nitrogen = float(request.form['nitrogen'])
        phosphorus = float(request.form['phosphorus'])
        potassium = float(request.form['potassium'])
        ph = float(request.form['ph'])
        rainfall = float(request.form['rainfall'])
        temperature = float(request.form['temperature'])

        # Scale features and make predictions
        features = np.array([[nitrogen, phosphorus, potassium, ph, rainfall, temperature]])
        features_scaled = scaler.transform(features)
        crop_pred, fertilizer_pred, fertilizer_usage_pred = fertilizer_model.predict(features_scaled)

        # Decode predictions
        crop_pred = crop_encoder.inverse_transform([np.argmax(crop_pred)])[0]
        fertilizer_pred = fertilizer_encoder.inverse_transform([np.argmax(fertilizer_pred)])[0]
        fertilizer_usage_pred = fertilizer_usage_pred[0][0]

        # Generate PDF report
        pdf_filename = str(uuid.uuid4()) + ".pdf"
        pdf_path = os.path.join(PDF_PATH, pdf_filename)

        # Ensure the reports directory exists
        if not os.path.exists(PDF_PATH):
            os.makedirs(PDF_PATH)

        pdf_path = generate_pdf_report(
            [
                "Crop Fertilizer Report",
                "Input Features:",
                f"Nitrogen: {nitrogen} kg/ha",
                f"Phosphorus: {phosphorus} kg/ha",
                f"Potassium: {potassium} kg/ha",
                f"pH: {ph}",
                f"Rainfall: {rainfall} mm",
                f"Temperature: {temperature} Â°C",
                "Predictions:",
                f"Crop: {crop_pred}",
                f"Fertilizer: {fertilizer_pred}",
                f"Fertilizer Usage: {fertilizer_usage_pred:.2f} kg/ha"
            ],
            pdf_path
        )

        return jsonify({
            "crop": crop_pred,
            "fertilizer": fertilizer_pred,
            "fertilizer_usage": f"{fertilizer_usage_pred:.2f} kg/ha",
            "pdf_filename": pdf_filename
        })
    except Exception as e:
        return jsonify({"error": str(e)})  
@app.route('/predict_disease', methods=['POST'])
def predict_disease():
    # Corrected key: cropImage
    if 'cropImage' not in request.files:
        return jsonify({'error': 'No file part'}), 400

    file = request.files['cropImage']  # Corrected key
    if file.filename == '':
        return jsonify({'error': 'No file selected'}), 400

    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        file.save(file_path)

        # Predict plant disease
        predicted_class = predict_image(file_path)

        if predicted_class in plant_solutions:
            prediction = plant_solutions[predicted_class]
            pdf_content = [
                "Plant Disease Report",
                f"Disease: {predicted_class}",
                f"Symptoms: {prediction.get('symptoms', 'N/A')}",
                f"Solution: {prediction.get('solution', 'N/A')}",
                f"Pesticide: {prediction.get('pesticide', 'N/A')}"
            ]
            report_filename = f"{predicted_class}_report.pdf"
            report_path = os.path.join(app.config['REPORT_FOLDER'], report_filename)
            generate_pdf_report(pdf_content, report_path)

            return jsonify({
                'disease': predicted_class,
                'symptoms': prediction.get('symptoms', 'N/A'),
                'solution': prediction.get('solution', 'N/A'),
                'pesticide': prediction.get('pesticide', 'N/A'),
                'pdf_filename': report_filename
            })
        else:
            return jsonify({'error': 'Disease not found in the database.'}), 404
    else:
        return jsonify({'error': 'Invalid file type. Please upload a valid image.'}), 400

if __name__ == '__main__':
  app.run(debug=True) 